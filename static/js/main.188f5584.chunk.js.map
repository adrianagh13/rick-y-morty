{"version":3,"sources":["index.js","images/logo.png"],"names":["CharacterCard","props","character","className","style","backgroundImage","image","name","App","state","loading","error","data","info","results","nextPage","fetchCharacters","a","setState","fetch","response","json","concat","this","src","Logo","alt","map","key","id","next","onClick","React","Component","rootElement","document","getElementById","ReactDOM","render","module","exports"],"mappings":"2QAMA,SAASA,EAAcC,GAAM,IACjBC,EAAcD,EAAdC,UAER,OACI,yBACIC,UAAU,gBACVC,MAAO,CAAEC,gBAAgB,OAAD,OAASH,EAAUI,MAAnB,OAExB,yBAAKH,UAAU,+CACVD,EAAUK,O,IAMrBC,E,4MACFC,MAAQ,CACJC,SAAS,EACTC,MAAO,KACPC,KAAM,CACFC,KAAM,GACNC,QAAS,IAEbC,SAAU,G,EAMdC,gB,sBAAkB,8BAAAC,EAAA,6DACd,EAAKC,SAAS,CAACR,SAAQ,EAAMC,MAAM,OADrB,kBAIaQ,MAAM,mDAAD,OAAoD,EAAKV,MAAMM,WAJjF,cAIJK,EAJI,gBAKSA,EAASC,OALlB,OAKJT,EALI,OAOV,EAAKM,SAAS,CACVR,SAAS,EACTC,OAAO,EACPC,KAAM,CACFC,KAAMD,EAAKC,KACXC,QAAS,GAAGQ,OAAO,EAAKb,MAAMG,KAAKE,QAASF,EAAKE,UAErDC,SAAW,EAAKN,MAAMM,SAAW,IAd3B,kDAiBV,EAAKG,SAAS,CAACR,SAAQ,EAAOC,OAAO,IAjB3B,0D,kEAHdY,KAAKP,oB,+BAyBA,IAAD,OACJ,OAAGO,KAAKd,MAAME,MACH,SAIP,yBAAKR,UAAU,aACX,yBAAKA,UAAU,OACX,yBAAKA,UAAU,OAAOqB,IAAKC,IAAMC,IAAI,KAErC,wBAAIvB,UAAU,OACToB,KAAKd,MAAMG,KAAKE,QAAQa,KAAK,SAAAzB,GAAS,OACnC,wBAAIC,UAAU,iBAAiByB,IAAK1B,EAAU2B,IAC1C,kBAAC7B,EAAD,CAAeE,UAAWA,SAKrCqB,KAAKd,MAAMC,SAAW,uBAAGP,UAAU,eAAb,eAErBoB,KAAKd,MAAMC,SAAWa,KAAKd,MAAMG,KAAKC,KAAKiB,MACzC,4BAAQC,QAAS,kBAAM,EAAKf,oBAA5B,mB,GAzDNgB,IAAMC,WAmElBC,EAAcC,SAASC,eAAe,QAC5CC,IAASC,OAAO,kBAAC9B,EAAD,MAAS0B,I,uCCzFzBK,EAAOC,QAAU,IAA0B,mC","file":"static/js/main.188f5584.chunk.js","sourcesContent":["import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\nimport Logo from './images/logo.png'\r\nimport './styles/styles.css'\r\n\r\nfunction CharacterCard(props){ //CharacaterCard representa cada una de las tarjetas de los personajes\r\n    const { character } = props; //creamos un obj character, que es equivalente a los props que recibe el componente\r\n\r\n    return (\r\n        <div \r\n            className=\"CharacterCard\"\r\n            style={{ backgroundImage: `url(${character.image})` }}\r\n        >\r\n            <div className=\"CharacterCard__name-container text-truncate\">\r\n                {character.name}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nclass App extends React.Component{\r\n    state = { //Inicializamos el estado así como sus 3 fases\r\n        loading: true,\r\n        error: null,\r\n        data: {\r\n            info: {},\r\n            results: []\r\n        },\r\n        nextPage: 1,\r\n    }\r\n    componentDidMount(){ //cuando el componente haga el montaje, se lanzará la función fetchCharacters\r\n        this.fetchCharacters()\r\n    }\r\n\r\n    fetchCharacters = async () => { \r\n        this.setState({loading:true, error:null}) //Al inicializar la función fetchCharacters, establecemos cambios en el estado previos a las peticiones \r\n\r\n        try{\r\n            const response = await fetch(`https://rickandmortyapi.com/api/character/?page=${this.state.nextPage}`) //la api por cada página proveé 20 resultados \r\n            const data = await response.json()\r\n            // console.log(data)\r\n            this.setState({ //si la peticion fue exitosa, se establecerá el estado de la manera que indica\r\n                loading: false,\r\n                error: false,\r\n                data: {\r\n                    info: data.info,\r\n                    results: [].concat(this.state.data.results, data.results) //para que no se borren los resultados previos, concatenamos lo que tenia el array con los neuvos resultados\r\n                },\r\n                nextPage : this.state.nextPage + 1, //queremos conocer los resultados de las siguientes páginas por lo tanto incrementamos cada vez 1 página más\r\n            })\r\n        }catch(error){ //si sucede un error se establecerá el estado de esta manera\r\n            this.setState({loading:false, error: true})\r\n        }\r\n    }\r\n\r\n    //Posterior al montaje del componente, se renderizan los resultados\r\n    render(){ //si hubo un error en state, debe retornar Error!\r\n        if(this.state.error){\r\n            return \"Error!\"\r\n        }\r\n\r\n        return(\r\n            <div className=\"container\">\r\n                <div className=\"App\">\r\n                    <img className=\"Logo\" src={Logo} alt=\"\"/>\r\n\r\n                    <ul className=\"row\">\r\n                        {this.state.data.results.map( character => (\r\n                            <li className=\"col-6 col-md-3\" key={character.id}>\r\n                                <CharacterCard character={character}/>\r\n                            </li>\r\n                        ))}\r\n                    </ul>\r\n\r\n                    {this.state.loading && <p className=\"text-center\">Loading...</p>} \r\n\r\n                    {!this.state.loading && this.state.data.info.next && (\r\n                        <button onClick={() => this.fetchCharacters()}>Load more</button>\r\n                    )}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n//El operador && en React representa un renderizado condicional, hace alusión a un if(true){ }, debido a que si lo que indicamos es verdadero, sucederá lo que indica el operador de renderizado condicional\r\n\r\nconst rootElement = document.getElementById('root')\r\nReactDOM.render(<App />, rootElement)","module.exports = __webpack_public_path__ + \"static/media/logo.42d6efdb.png\";"],"sourceRoot":""}